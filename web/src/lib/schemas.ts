//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           2.8.5
//
//
//       bebopc source:
//           https://github.com/RainwayApp/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, BebopRecord, BebopJson, BebopTypeGuard, Guid, GuidMap } from "bebop";

export enum ClientMessageType {
  Ping = 1,
  CursorLocation = 2,
  FinishStroke = 3,
  Clear = 4,
  Vote = 15,
  AuthADM = 25,
  StageChangeADM = 26,
  StartADM = 27,
  EndADM = 28,
}

export interface IVote extends BebopRecord {
  choice: GamerChoice;
}

export class Vote implements IVote {
  public choice: GamerChoice;

  constructor(record: IVote) {
    this.choice = record.choice;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return Vote.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IVote): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Vote.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Vote}.
   */
  public static validateCompatibility(record: IVote): void {
    BebopTypeGuard.ensureEnum(record.choice, GamerChoice);
  }

  /**
   * Unsafely creates an instance of {@link Vote} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IVote {
      return new Vote(record);
  }

  /**
   * Creates a new {@link Vote} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IVote {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Vote.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Vote.validateCompatibility(parsed);
    return Vote.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Vote.encode(this);
  }

  public static encode(record: IVote): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Vote.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IVote, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.choice);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IVote {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Vote.readFrom(view);
  }

  public static readFrom(view: BebopView): IVote {
    let field0: GamerChoice;
    field0 = view.readUint32() as GamerChoice;
    let message: IVote = {
      choice: field0,
    };
    return new Vote(message);
  }
}

export enum Stage {
  GamerSelect = 1,
  AudienceLobby = 2,
  Drawing = 3,
  Voting = 4,
  Judging = 5,
  Results = 6,
}

export enum ServerMessageType {
  Ping = 1,
  GameState = 2,
  ClientTypeDTO = 3,
  ClientJoined = 4,
  DrawUpdate = 5,
  FinishStroke = 6,
  VoteUpdate = 7,
  Clear = 8,
  NewSTG = 28,
  AudienceLobbySTG = 29,
  DrawingSTG = 30,
  VotingSTG = 31,
  JudgingSTG = 32,
  ResultsSTG = 33,
}

export interface IDrawUpdate extends BebopRecord {
  cursor: ICursorLocation;
  gamer: GamerChoice;
}

export class DrawUpdate implements IDrawUpdate {
  public cursor: ICursorLocation;
  public gamer: GamerChoice;

  constructor(record: IDrawUpdate) {
    this.cursor = record.cursor;
    this.gamer = record.gamer;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return DrawUpdate.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IDrawUpdate): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    DrawUpdate.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link DrawUpdate}.
   */
  public static validateCompatibility(record: IDrawUpdate): void {
    CursorLocation.validateCompatibility(record.cursor);
    BebopTypeGuard.ensureEnum(record.gamer, GamerChoice);
  }

  /**
   * Unsafely creates an instance of {@link DrawUpdate} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IDrawUpdate {
      record.cursor = CursorLocation.unsafeCast(record.cursor);
      return new DrawUpdate(record);
  }

  /**
   * Creates a new {@link DrawUpdate} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IDrawUpdate {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`DrawUpdate.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    DrawUpdate.validateCompatibility(parsed);
    return DrawUpdate.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return DrawUpdate.encode(this);
  }

  public static encode(record: IDrawUpdate): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    DrawUpdate.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IDrawUpdate, view: BebopView): number {
    const before = view.length;
    CursorLocation.encodeInto(record.cursor, view)
    view.writeUint32(record.gamer);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IDrawUpdate {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return DrawUpdate.readFrom(view);
  }

  public static readFrom(view: BebopView): IDrawUpdate {
    let field0: ICursorLocation;
    field0 = CursorLocation.readFrom(view);
    let field1: GamerChoice;
    field1 = view.readUint32() as GamerChoice;
    let message: IDrawUpdate = {
      cursor: field0,
      gamer: field1,
    };
    return new DrawUpdate(message);
  }
}

export interface IGameState extends BebopRecord {
  id: Guid;
  stage: Stage;
  clients: Array<ClientType>;
  drawingA: Array<IStroke>;
  drawingB: Array<IStroke>;
}

export class GameState implements IGameState {
  public id: Guid;
  public stage: Stage;
  public clients: Array<ClientType>;
  public drawingA: Array<IStroke>;
  public drawingB: Array<IStroke>;

  constructor(record: IGameState) {
    this.id = record.id;
    this.stage = record.stage;
    this.clients = record.clients;
    this.drawingA = record.drawingA;
    this.drawingB = record.drawingB;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return GameState.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IGameState): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    GameState.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link GameState}.
   */
  public static validateCompatibility(record: IGameState): void {
    BebopTypeGuard.ensureGuid(record.id)
    BebopTypeGuard.ensureEnum(record.stage, Stage);
    BebopTypeGuard.ensureArray(record.clients, (value) => BebopTypeGuard.ensureEnum(value, ClientType));
    BebopTypeGuard.ensureArray(record.drawingA, Stroke.validateCompatibility);
    BebopTypeGuard.ensureArray(record.drawingB, Stroke.validateCompatibility);
  }

  /**
   * Unsafely creates an instance of {@link GameState} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IGameState {
      return new GameState(record);
  }

  /**
   * Creates a new {@link GameState} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IGameState {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`GameState.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    GameState.validateCompatibility(parsed);
    return GameState.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return GameState.encode(this);
  }

  public static encode(record: IGameState): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    GameState.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IGameState, view: BebopView): number {
    const before = view.length;
    view.writeGuid(record.id);
    view.writeUint32(record.stage);
    {
      const length0 = record.clients.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        view.writeUint32(record.clients[i0]);
      }
    }
    {
      const length0 = record.drawingA.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Stroke.encodeInto(record.drawingA[i0], view)
      }
    }
    {
      const length0 = record.drawingB.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        Stroke.encodeInto(record.drawingB[i0], view)
      }
    }
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IGameState {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return GameState.readFrom(view);
  }

  public static readFrom(view: BebopView): IGameState {
    let field0: Guid;
    field0 = view.readGuid();
    let field1: Stage;
    field1 = view.readUint32() as Stage;
    let field2: Array<ClientType>;
    {
      let length0 = view.readUint32();
      field2 = new Array<ClientType>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: ClientType;
        x0 = view.readUint32() as ClientType;
        field2[i0] = x0;
      }
    }
    let field3: Array<IStroke>;
    {
      let length0 = view.readUint32();
      field3 = new Array<IStroke>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IStroke;
        x0 = Stroke.readFrom(view);
        field3[i0] = x0;
      }
    }
    let field4: Array<IStroke>;
    {
      let length0 = view.readUint32();
      field4 = new Array<IStroke>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: IStroke;
        x0 = Stroke.readFrom(view);
        field4[i0] = x0;
      }
    }
    let message: IGameState = {
      id: field0,
      stage: field1,
      clients: field2,
      drawingA: field3,
      drawingB: field4,
    };
    return new GameState(message);
  }
}

export interface IStroke extends BebopRecord {
  locs: Array<ICursorLocation>;
}

export class Stroke implements IStroke {
  public locs: Array<ICursorLocation>;

  constructor(record: IStroke) {
    this.locs = record.locs;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return Stroke.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IStroke): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Stroke.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Stroke}.
   */
  public static validateCompatibility(record: IStroke): void {
    BebopTypeGuard.ensureArray(record.locs, CursorLocation.validateCompatibility);
  }

  /**
   * Unsafely creates an instance of {@link Stroke} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IStroke {
      return new Stroke(record);
  }

  /**
   * Creates a new {@link Stroke} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IStroke {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Stroke.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Stroke.validateCompatibility(parsed);
    return Stroke.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Stroke.encode(this);
  }

  public static encode(record: IStroke): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Stroke.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IStroke, view: BebopView): number {
    const before = view.length;
    {
      const length0 = record.locs.length;
      view.writeUint32(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        CursorLocation.encodeInto(record.locs[i0], view)
      }
    }
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IStroke {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Stroke.readFrom(view);
  }

  public static readFrom(view: BebopView): IStroke {
    let field0: Array<ICursorLocation>;
    {
      let length0 = view.readUint32();
      field0 = new Array<ICursorLocation>(length0);
      for (let i0 = 0; i0 < length0; i0++) {
        let x0: ICursorLocation;
        x0 = CursorLocation.readFrom(view);
        field0[i0] = x0;
      }
    }
    let message: IStroke = {
      locs: field0,
    };
    return new Stroke(message);
  }
}

export interface IClientJoined extends BebopRecord {
  newClient: ClientType;
}

export class ClientJoined implements IClientJoined {
  public newClient: ClientType;

  constructor(record: IClientJoined) {
    this.newClient = record.newClient;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return ClientJoined.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IClientJoined): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    ClientJoined.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link ClientJoined}.
   */
  public static validateCompatibility(record: IClientJoined): void {
    BebopTypeGuard.ensureEnum(record.newClient, ClientType);
  }

  /**
   * Unsafely creates an instance of {@link ClientJoined} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IClientJoined {
      return new ClientJoined(record);
  }

  /**
   * Creates a new {@link ClientJoined} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IClientJoined {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`ClientJoined.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    ClientJoined.validateCompatibility(parsed);
    return ClientJoined.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return ClientJoined.encode(this);
  }

  public static encode(record: IClientJoined): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    ClientJoined.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IClientJoined, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.newClient);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IClientJoined {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return ClientJoined.readFrom(view);
  }

  public static readFrom(view: BebopView): IClientJoined {
    let field0: ClientType;
    field0 = view.readUint32() as ClientType;
    let message: IClientJoined = {
      newClient: field0,
    };
    return new ClientJoined(message);
  }
}

export interface ISTgNew extends BebopRecord {
  id: Guid;
}

export class STgNew implements ISTgNew {
  public id: Guid;

  constructor(record: ISTgNew) {
    this.id = record.id;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return STgNew.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISTgNew): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    STgNew.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link STgNew}.
   */
  public static validateCompatibility(record: ISTgNew): void {
    BebopTypeGuard.ensureGuid(record.id)
  }

  /**
   * Unsafely creates an instance of {@link STgNew} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISTgNew {
      return new STgNew(record);
  }

  /**
   * Creates a new {@link STgNew} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISTgNew {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`STgNew.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    STgNew.validateCompatibility(parsed);
    return STgNew.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return STgNew.encode(this);
  }

  public static encode(record: ISTgNew): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    STgNew.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISTgNew, view: BebopView): number {
    const before = view.length;
    view.writeGuid(record.id);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISTgNew {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return STgNew.readFrom(view);
  }

  public static readFrom(view: BebopView): ISTgNew {
    let field0: Guid;
    field0 = view.readGuid();
    let message: ISTgNew = {
      id: field0,
    };
    return new STgNew(message);
  }
}

export interface IClear extends BebopRecord {
  gamer: GamerChoice;
}

export class Clear implements IClear {
  public gamer: GamerChoice;

  constructor(record: IClear) {
    this.gamer = record.gamer;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return Clear.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IClear): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Clear.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Clear}.
   */
  public static validateCompatibility(record: IClear): void {
    BebopTypeGuard.ensureEnum(record.gamer, GamerChoice);
  }

  /**
   * Unsafely creates an instance of {@link Clear} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IClear {
      return new Clear(record);
  }

  /**
   * Creates a new {@link Clear} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IClear {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Clear.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Clear.validateCompatibility(parsed);
    return Clear.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Clear.encode(this);
  }

  public static encode(record: IClear): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Clear.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IClear, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.gamer);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IClear {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Clear.readFrom(view);
  }

  public static readFrom(view: BebopView): IClear {
    let field0: GamerChoice;
    field0 = view.readUint32() as GamerChoice;
    let message: IClear = {
      gamer: field0,
    };
    return new Clear(message);
  }
}

export interface ISTgResults extends BebopRecord {
  id: Guid;
}

export class STgResults implements ISTgResults {
  public id: Guid;

  constructor(record: ISTgResults) {
    this.id = record.id;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return STgResults.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ISTgResults): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    STgResults.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link STgResults}.
   */
  public static validateCompatibility(record: ISTgResults): void {
    BebopTypeGuard.ensureGuid(record.id)
  }

  /**
   * Unsafely creates an instance of {@link STgResults} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ISTgResults {
      return new STgResults(record);
  }

  /**
   * Creates a new {@link STgResults} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ISTgResults {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`STgResults.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    STgResults.validateCompatibility(parsed);
    return STgResults.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return STgResults.encode(this);
  }

  public static encode(record: ISTgResults): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    STgResults.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ISTgResults, view: BebopView): number {
    const before = view.length;
    view.writeGuid(record.id);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ISTgResults {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return STgResults.readFrom(view);
  }

  public static readFrom(view: BebopView): ISTgResults {
    let field0: Guid;
    field0 = view.readGuid();
    let message: ISTgResults = {
      id: field0,
    };
    return new STgResults(message);
  }
}

export interface IPing extends BebopRecord {
  msg: string;
  test: boolean;
}

export class Ping implements IPing {
  public msg: string;
  public test: boolean;

  constructor(record: IPing) {
    this.msg = record.msg;
    this.test = record.test;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return Ping.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IPing): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Ping.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Ping}.
   */
  public static validateCompatibility(record: IPing): void {
    BebopTypeGuard.ensureString(record.msg)
    BebopTypeGuard.ensureBoolean(record.test)
  }

  /**
   * Unsafely creates an instance of {@link Ping} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IPing {
      return new Ping(record);
  }

  /**
   * Creates a new {@link Ping} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IPing {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Ping.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Ping.validateCompatibility(parsed);
    return Ping.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Ping.encode(this);
  }

  public static encode(record: IPing): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Ping.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IPing, view: BebopView): number {
    const before = view.length;
    view.writeString(record.msg);
    view.writeByte(Number(record.test));
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IPing {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Ping.readFrom(view);
  }

  public static readFrom(view: BebopView): IPing {
    let field0: string;
    field0 = view.readString();
    let field1: boolean;
    field1 = !!view.readByte();
    let message: IPing = {
      msg: field0,
      test: field1,
    };
    return new Ping(message);
  }
}

export interface IClientTypeDTO extends BebopRecord {
  gamerId: number;
  id: number;
  ctype: ClientType;
}

export class ClientTypeDTO implements IClientTypeDTO {
  public gamerId: number;
  public id: number;
  public ctype: ClientType;

  constructor(record: IClientTypeDTO) {
    this.gamerId = record.gamerId;
    this.id = record.id;
    this.ctype = record.ctype;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return ClientTypeDTO.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: IClientTypeDTO): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    ClientTypeDTO.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link ClientTypeDTO}.
   */
  public static validateCompatibility(record: IClientTypeDTO): void {
    BebopTypeGuard.ensureUint8(record.gamerId)
    BebopTypeGuard.ensureUint32(record.id)
    BebopTypeGuard.ensureEnum(record.ctype, ClientType);
  }

  /**
   * Unsafely creates an instance of {@link ClientTypeDTO} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): IClientTypeDTO {
      return new ClientTypeDTO(record);
  }

  /**
   * Creates a new {@link ClientTypeDTO} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): IClientTypeDTO {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`ClientTypeDTO.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    ClientTypeDTO.validateCompatibility(parsed);
    return ClientTypeDTO.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return ClientTypeDTO.encode(this);
  }

  public static encode(record: IClientTypeDTO): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    ClientTypeDTO.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: IClientTypeDTO, view: BebopView): number {
    const before = view.length;
    view.writeByte(record.gamerId);
    view.writeUint32(record.id);
    view.writeUint32(record.ctype);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): IClientTypeDTO {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return ClientTypeDTO.readFrom(view);
  }

  public static readFrom(view: BebopView): IClientTypeDTO {
    let field0: number;
    field0 = view.readByte();
    let field1: number;
    field1 = view.readUint32();
    let field2: ClientType;
    field2 = view.readUint32() as ClientType;
    let message: IClientTypeDTO = {
      gamerId: field0,
      id: field1,
      ctype: field2,
    };
    return new ClientTypeDTO(message);
  }
}

export const AUDIENCE_LOBBY_TIME: number = 30000;

export const DRAWING_TIME: number = 60000;

export interface ICoord extends BebopRecord {
  x: number;
  y: number;
}

export class Coord implements ICoord {
  public x: number;
  public y: number;

  constructor(record: ICoord) {
    this.x = record.x;
    this.y = record.y;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return Coord.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ICoord): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    Coord.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link Coord}.
   */
  public static validateCompatibility(record: ICoord): void {
    BebopTypeGuard.ensureUint32(record.x)
    BebopTypeGuard.ensureUint32(record.y)
  }

  /**
   * Unsafely creates an instance of {@link Coord} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ICoord {
      return new Coord(record);
  }

  /**
   * Creates a new {@link Coord} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ICoord {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`Coord.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    Coord.validateCompatibility(parsed);
    return Coord.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return Coord.encode(this);
  }

  public static encode(record: ICoord): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    Coord.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ICoord, view: BebopView): number {
    const before = view.length;
    view.writeUint32(record.x);
    view.writeUint32(record.y);
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ICoord {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return Coord.readFrom(view);
  }

  public static readFrom(view: BebopView): ICoord {
    let field0: number;
    field0 = view.readUint32();
    let field1: number;
    field1 = view.readUint32();
    let message: ICoord = {
      x: field0,
      y: field1,
    };
    return new Coord(message);
  }
}

export interface ICursorLocation extends BebopRecord {
  currentPoint: ICoord;
}

export class CursorLocation implements ICursorLocation {
  public currentPoint: ICoord;

  constructor(record: ICursorLocation) {
    this.currentPoint = record.currentPoint;
  }

  /**
   * Serializes the current instance into a JSON-Over-Bebop string
   */
  public toJSON(): string {
    return CursorLocation.encodeToJSON(this);
  }

  /**
   * Serializes the specified object into a JSON-Over-Bebop string
   */
  public static encodeToJSON(record: ICursorLocation): string {
    return JSON.stringify(record, BebopJson.replacer);
  }

  /**
   * Validates that the runtime types of members in the current instance are correct.
   */
  public validateTypes(): void {
    CursorLocation.validateCompatibility(this);
  }

  /**
   * Validates that the specified dynamic object can become an instance of {@link CursorLocation}.
   */
  public static validateCompatibility(record: ICursorLocation): void {
    Coord.validateCompatibility(record.currentPoint);
  }

  /**
   * Unsafely creates an instance of {@link CursorLocation} from the specified dynamic object. No type checking is performed.
   */
  public static unsafeCast(record: any): ICursorLocation {
      record.currentPoint = Coord.unsafeCast(record.currentPoint);
      return new CursorLocation(record);
  }

  /**
   * Creates a new {@link CursorLocation} instance from a JSON-Over-Bebop string. Type checking is performed.
   */
  public static fromJSON(json: string): ICursorLocation {
    if (typeof json !== 'string' || json.trim().length === 0) {
      throw new BebopRuntimeError(`CursorLocation.fromJSON: expected string`);
    }
    const parsed = JSON.parse(json, BebopJson.reviver);
    CursorLocation.validateCompatibility(parsed);
    return CursorLocation.unsafeCast(parsed);
  }
  public encode(): Uint8Array {
    return CursorLocation.encode(this);
  }

  public static encode(record: ICursorLocation): Uint8Array {
    const view = BebopView.getInstance();
    view.startWriting();
    CursorLocation.encodeInto(record, view);
    return view.toArray();
  }

  public static encodeInto(record: ICursorLocation, view: BebopView): number {
    const before = view.length;
    Coord.encodeInto(record.currentPoint, view)
    const after = view.length;
    return after - before;
  }

  public static decode(buffer: Uint8Array): ICursorLocation {
    const view = BebopView.getInstance();
    view.startReading(buffer);
    return CursorLocation.readFrom(view);
  }

  public static readFrom(view: BebopView): ICursorLocation {
    let field0: ICoord;
    field0 = Coord.readFrom(view);
    let message: ICursorLocation = {
      currentPoint: field0,
    };
    return new CursorLocation(message);
  }
}

export enum GamerChoice {
  GamerA = 1,
  GamerB = 2,
  Neither = 3,
}

export enum ClientType {
  Gamer = 1,
  Audience = 2,
  Admin = 3,
  Unknown = 4,
}

